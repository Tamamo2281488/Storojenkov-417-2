#include<iostream>
#include<locale.h>
#include<iomanip>
#include<bitset>


int main()
{
	setlocale(LC_ALL, "Russian");

	int binary_int01 = 0b1011;
	int binary_int02 = 0b1100;
	std::cout << "Таблица бинарных значений " << std::endl;
	std::cout << "Бинарное число 01 = " << std::hex << std::bitset<4>(binary_int01) << std::endl;
	std::cout << "Бинарное число 02 = " << std::hex << std::bitset<4>(binary_int02) << std::endl;
	std::cout << " —----" << std::hex << std::endl;
	std::cout << "Результат " << std::hex << std::bitset <4>(binary_int01 ^ binary_int02) << std::endl;

	int binary_int03 = 0b1011;
	int binary_int04 = 0b1100;
	std::cout << "Таблица бинарных значений " << std::endl;
	std::cout << "Бинарное число 01 = " << std::hex << std::bitset<4>(binary_int03) << std::endl;
	std::cout << "Бинарное число 02 = " << std::hex << std::bitset<4>(binary_int04) << std::endl;
	std::cout << " —----" << std::hex << std::endl;
	std::cout << "Результат " << std::hex << std::bitset <4>(binary_int03 & binary_int04) << std::endl;

	int binary_int05 = 0b1011;
	int binary_int06 = 0b1100;
	std::cout << "Таблица бинарных значений " << std::endl;
	std::cout << "Бинарное число 01 = " << std::hex << std::bitset<4>(binary_int05) << std::endl;
	std::cout << "Бинарное число 02 = " << std::hex << std::bitset<4>(binary_int06) << std::endl;
	std::cout << " —----" << std::hex << std::endl;
	std::cout << "Результат " << std::hex << std::bitset <4>(binary_int05 | binary_int06) << std::endl;

	std::cout << "демонстарция оператора << " << std::hex << std::bitset <4>(binary_int01 << binary_int02) << std::endl;

	std::cout << "демонстарция оператора >> " << std::hex << std::bitset <4>(binary_int03 >> binary_int04) << std::endl;

	std::cout << "демонстарция оператора ~ " << std::hex << std::bitset <4>(~binary_int05) << std::endl;

	int c = 2;
	int a = 3;
	int d = 4;
	int b = 1;

	/* 2. унарные, бинарные и один тернарный
	унарные - работающие с единственным операндом ( пример - !, ~, ++, —)
	бинарные - работают с двумя операндами (примеры +, -, >>, <<, &&, ||, &, |, ^, /, *, %)
	тернарный - работает с тремя операндами (логическое_условие?ветка_если_true:ветка_если_false )
	операнд - данные, к которым применяется оператор

	—-----------------------------------------------------------------—

	демонстрация работы побитовых операторов
	*/
	std::cout << "a = " << std::bitset<8>(a) << "; b =" << b
		<< "; a >> b = " << std::bitset<8>(a >> b) << std::endl;

	std::cout << "a = " << std::bitset<8>(a) << "; b = " << b
		<< "; a >> b = " << std::bitset<8>(a << b) << std::endl;

	std::cout << "a = " << std::bitset<8>(a) << "; ~a = " << std::bitset<8>(~a) << std::endl;

	//если оператор ++ стоит после числа, то число сначала выводится на печать, а затем увеличивается
	//если оператор ++ стоит перед числом, то число сначала увеличивается а затем выводится на печать




	//ТИПЫ ДАННЫХ ЯЗЫКА С/С++

	//2.1 целочисленные типы используются для хранения целых чисел положительынбъ, отрицательных и беззнаковых

	char uchar_var; //название любое | Занимает памяти 8 бит (байт) может хранить числа от -128 до 127
	short short_var; // занимает в памяти 16 бит ( 2 байта) хранит числа от 32 767 до -32 768
	int int_var; // занимает в памяти 32 бита ( 4 байта) хранит числа от int32_min до int32_max
	long long_var; // аналогична int
	long int li_var; // занимает 64 бит (8 байт) хранит от llong_min до llong_max
	long long uli_var; // аналог long int


	//если приписать к любому целому знаоковму типу модификатор unsign, то
	// положительный диапазон (т.е максимально положительное число увеличивается в 2 раза
	// в число с меткой unsign нельзя будет записать отрицательные числа

	unsigned char char_var; //размер тот же что и у типа char но диапазон начинается с 0 до 255 (127*2+1)
	unsigned short ushort_var; // аналогично
	unsigned int uint_var; // аналогично
	unsigned long ulong_var; // аналогично
	unsigned long int uuli_var; // аналогично
	unsigned long

		long uuuli_var; // аналогично

		//2.2 арифметические типы с плавающей запятой/точкой
	float float_var; // имеет объем 4 байта (32 бита) и может представлять числа от flt_min до flt_max
	double dbl_var; // имеет объем 8 байт ( 64 бита) может представлять от dbl_min до dbl_max

	//2.3 логические типы данных

	bool bool_var; //может представлять всего 2 значения true и false но имеет длину
	std::cout << std::endl << "длина типа bool(в 64 разрядном приложении) sizeif(bool) = "
		<< sizeof(bool) << std::endl;
	//2.4 символьные типы данных
	char chr_var; //диапазона ариыметического типа char очень кстати хватает на кодирование таблицы символов
	//поэтому чаще тип char используется именно для хранения символов и строк чем для арифметики

	wchar_t wchr_var; //имеет объем 16 бит (2 байта) и введен для хранения символов юникода
	//или других расширенных кодировок

	//2.5 универсальный или пустой тип void
	//компилятор рассматривает void просто как ячейку с неопределенными данными
	//служебный тип данных может использоваться как заглушка если функция не возвращает и не принимает значений либо в сложных конструкциях







	std::system("pause"); // вызов функции system() из стандартной библиотеки

	return 0;
}
